# Header file `module.hpp`

``` cpp
namespace exactreal
{
    template <typename Ring>
    class Module;
     
    //=== Other Means of Constructing Modules ===//
    template <typename Ring>
    std::shared_ptr<const Module<Ring>> operator+(std::shared_ptr<const Module<Ring>>&, std::shared_ptr<const Module<Ring>>&);
}
```

### Class `exactreal::Module`

``` cpp
template <typename Ring>
class Module
: public std::enable_shared_from_this<Module<Ring>>, public boost::equality_comparable<Module<Ring>>
{
public:
    using Basis = std::vector<std::shared_ptr<const RealNumber>>;
     
    //=== Constructors ===//
    static std::shared_ptr<const Module<Ring>> make(exactreal::Module::Basis const&);
    static std::shared_ptr<const Module<Ring>> make(exactreal::Module::Basis const&, Ring const&);
     
    //=== Basic Properties ===//
    Ring const& ring() const noexcept;
    Basis& basis() const noexcept;
    exactreal::size rank() const noexcept;
     
    //=== Generators ===//
    Element<Ring> gen(exactreal::size i) const;
     
    //=== Comparisons ===//
    bool operator==(Module<Ring> const& rhs) const;
};
```

A module over a `Ring` such as the [IntegerRing](doc_integer_ring.md#standardese-exactreal), the [RationalField](doc_rational_field.md#standardese-exactreal), or a [NumberField](doc_number_field.md#standardese-exactreal) generated by a basis of [RealNumber](doc_real_number.md#standardese-exactreal).

### Constructors

``` cpp
(1) static std::shared_ptr<const Module<Ring>> make(exactreal::Module::Basis const&);
(2) static std::shared_ptr<const Module<Ring>> make(exactreal::Module::Basis const&, Ring const&);
```

Create a module that spans the generators in the given basis. If no `Ring` is passed in, the trivial ring of type `Ring` is assumed, i.e., the Integers, Rationals, or a trivial Number Field.

``` c++
#include <exact-real/module.hpp>
#include <exact-real/integer_ring.hpp>
#include <exact-real/real_number.hpp>
using namespace exactreal;

auto M = Module<IntegerRing>::make({ RealNumber::rational(1), RealNumber::random() });
```

We do not expose the `Module` constructor but force all calls to go though these factory functions. This is to make sure that modules are unique parents, i.e., two modules with the same (ordered) basis are actually identical:

``` c++
#include <e-antic/renfxx.h>
#include <exact-real/number_field.hpp>

auto K = eantic::renf_class("a^2 - 2", "a", "1.41 +/- .1");
auto N = Module<NumberField>::make({ RealNumber::rational(1), RealNumber::random() }, K);

assert(N == Module<NumberField>::make({ RealNumber::rational(1), RealNumber::random() }, K));
```

-----

### Basic Properties

``` cpp
Ring const& ring() const noexcept;
```

Return the underlying ring (e.g., the number field)

-----

### Function `exactreal::Module::basis`

``` cpp
Basis& basis() const noexcept;
```

Return a reference to the [RealNumbers](doc_real_number.md#standardese-exactreal) that were used to construct this module.

-----

### Function `exactreal::Module::rank`

``` cpp
exactreal::size rank() const noexcept;
```

Return `basis.size()`.

-----

### Generators

``` cpp
Element<Ring> gen(exactreal::size i) const;
```

Return the `i`ᵗʰ entry of the basis of this module as an [Element](doc_element.md#standardese-exactreal) of this module. To get the generator as a [RealNumber](doc_real_number.md#standardese-exactreal), use `basis()[i]`.

-----

### Comparisons

``` cpp
bool operator==(Module<Ring> const& rhs) const;
```

Return whether this module has the same generators in the same order over the same ring.

Through [boost operators](https://www.boost.org/doc/libs/1_70_0/libs/utility/operators.htm) there is also the corresponding operator `!=`. Usually, you won’t need this operator. Modules are unique parents, i.e., if they are equal they are identical objects in memory. In other words you can just compare the `shared_ptr<Module>` instead of the underlying object.

-----

-----

### Other Means of Constructing Modules

``` cpp
template <typename Ring>
std::shared_ptr<const Module<Ring>> operator+(std::shared_ptr<const Module<Ring>>&, std::shared_ptr<const Module<Ring>>&);
```

Return the span of two modules.

``` c++
assert(N + N == N);
```

-----
