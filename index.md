---
# Feel free to add content and custom Front Matter to this file.
# To modify the layout, see https://jekyllrb.com/docs/themes/#overriding-theme-defaults

layout: default
---

# Finite Real Submodules

[exact-real](https://github.com/flatsurf/exact-real) is a collection of libraries to work with finite submodules of \\(\mathbb{R}\\). libexactreal is the C++ core of exact-real.

# Getting Started

If you don't have libexactreal installed already, please see our [README](https://github.com/flatsurf/exact-real/README.md) on how to get a copy of libexactreal. You can also try things out without actually installing anything through our [binder](https://github.com/flatsurf/exact-real#run-with-binder-in-the-cloud). Finally, please note that there is also a Python interface [pyexactreal](https://github.com/flatsurf/exact-real/tree/master/pyexactreal) which might be more convenient to use for some first experiments.

The basic objects in libexactreal are [Modules](standardese/doc_module) over a ring, generated by a finite set of [Real Numbers](standardese/doc_real_number), and their [Elements](standardese/doc_element).

To generate such a module, you have to fix a base ring, say the ring of integers \\(\mathbb{Z}\\), and some generators.

```cpp
#include <iostream>
#include <exact-real/integer_ring.hpp>
#include <exact-real/real_number.hpp>
#include <exact-real/module.hpp>

using namespace exactreal;
using std::cout, std::endl;

auto ZZ = IntegerRing();
auto generator = RealNumber::rational({1, 2});
```

From this we create the \\(\mathbb{Z}\\)-module generated by \\(1/2\\).

```cpp
auto m = Module<IntegerRing>::make({generator}, ZZ);

cout << *m << endl;
// prints: ℤ-Module(1/2) 
```

# Types of Generators

Besides the rational generators above, there are several classes of transcendental generators. For example, a random transcendental[^transcendental] real in \\([0, 1]\\) can be created with `RealNumber::random()`:

```cpp
m = Module<IntegerRing>::make({
  RealNumber::rational(1),
  RealNumber::random(),
  RealNumber::random() }, ZZ);

cout << *m << endl;
// prints: ℤ-Module(1, ℝ(0.120809…), ℝ(0.178808…))
```

You can also change the interval from which the random number is taken or create a random real which is very close to a double precision floating point number:

```cpp
cout << *RealNumber::random(13, 37) << endl;
// prints: ℝ(17 + ℝ(0.782515…)p0)[∼17.3913]
cout << *RealNumber::random(13.37) << endl;
// prints: ℝ(13.37=15414560516593543199p-60 + ℝ(0.498661…)p-60)
```

For more details on the possible generators, see the documentation on [Real Numbers](standardese/doc_real_number); other means of creating modules can be found in the documentation of the [Module class](standardese/doc_module).

# Base Rings

We are not limited to \\(\mathbb{Z}\\)-modules. Currently, we also support the rationals and (embedded) real number fields.

```cpp
auto n = Module<RationalField>({ RealNumber::rational(1) });

cout << *n << endl;
// prints: ℚ-Module(1)
```

Number fields are powered by [e-antic](https://github.com/videlec/e-antic). To create an embedded number field, we need to specify the field's minimal polynomial and an embedding into the reals:

```cpp
#include <e-antic/renfxx.h>
#include <exact-real/number_field.hpp>

auto K = eantic::renf_class::make("a^2 - 2", "a", "1.41 +/- .1");
auto M = Module<NumberField>::make({ RealNumber::rational(1),
                                     RealNumber::random() }, K)

cout << *M << endl;
// prints: K-Module(1, ℝ(0.982253…))
```

# Arithmetic

Basic arithmetic with module elements is supported:

```cpp
cout << *M << endl;
// prints: K-Module(1, ℝ(0.982253…))

auto a = K.gen();
auto x = M->gen(1);

cout << x + x << endl;
// prints: 2*ℝ(0.982253…)

cout << a * x << endl;
// prints: (a ~ 1.414214)*ℝ(0.982253…)

cout << a + x << endl;
// prints: (a ~ 1.414214)*1 + ℝ(0.982253…)
```

Note that all operations are exact. Also comparison of elements is exact and guaranteed to terminate after a finite number of steps:

```cpp
auto r1 = RealNumber::random(13.37);
auto r2 = RealNumber::random(13.37);

auto N = Module<IntegerRing>::make({ RealNumber::rational(1), r1, r2 }, ZZ);
cout << *N << endl;
// prints: ℤ-Module(1, ℝ(13.37=15414560516593543133p-60 + ℝ(0.0349583…)p-60),
//                  ℝ(13.37=1926820064574192977p-57 + ℝ(0.424554…)p-60))
cout << N->gen(1) == N->gen(2) << endl;
// prints: false
cout << (N->gen(1) - N->gen(2)) > 0 << endl;
// prints: true
```

Divisions are also supported if the result is an element of the base ring:

```cpp
auto q = (a * x) / x;
cout << q.value() << endl;
// prints: (a ~ 1.414214) 

q = (1 + x) / x;
cout << q.value() << endl;
// Standard Exception: bad optional access
```

All the available operators are described in the documentation of our [Element class](standardese/doc_element).

## Coercion Into Supermodules

You can also multiply module elements, however, the result will usually live in a bigger module:

```cpp
auto y = (1 + x) * (1 - x);
cout << y << endl;
// prints: -1*ℝ(0.982253…)*ℝ(0.982253…) + 1
cout << *y.module() << endl;
// prints: K-Module(ℝ(0.982253…)*ℝ(0.982253…), ℝ(0.982253…), 1)
```

Operands are automatically coerced into an appropriate module during arithmetic:

```cpp
auto z = (y - x) - (x * x);
cout << z << endl;
// prints: -1*ℝ(0.982253…) + 1
cout << y.module() == z.module() << endl;
// prints: true
```

Internally, this coercion relies heavily on the fact that modules with the same generators are identical, i.e., they are exactly the same object in memory. This is achieved through our [unique-factory](https://github.com/flatsurf/unique-factory) library which tries to mimic SageMath's [UniqueFactory](http://doc.sagemath.org/html/en/reference/structure/sage/structure/factory.html).

## Serialization

All types in libexactreal can be serialized and deserialized with [Cereal](http://uscilab.github.io/cereal/quickstart.html):

```cpp
#include <exact-real/cereal.hpp>
#include <cereal/archives/json.hpp>

// You might want to use a file stream instead
std::stringstream s;

{
  cereal::JSONOutputArchive archive(s);
  archive(z);
}

cout << s.str() << endl;
// prints: { "value0": { "parent": { […] } } }

Element restored;

{
  cereal::JSONInputArchive archive(s);
  archive(restored);
}

cout << z == restored << endl;
// prints: true
```

For more details, consult our [serialization documentation](standarese/doc_cereal).

## C++ Interface for Arb

Internally, libexactreal relies heavily on [Arb](https://arblib.org), a C library for arbitrary-precision ball arithmetic. We implement a C++ interface for Arb that we will eventually move into a standalone library. This C++ interface is documented on its [own page](arb).

---

### Footnotes 

[^transcendental]: The digits of these numbers come out of a deterministic random number generator and are therefore going to repeat eventually. For all practical purposes, the sequence of digits should not be distinguishable from an actual transcendental real number.
